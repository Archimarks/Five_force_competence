/// ---------------------------------------------------------------------------
/// `AlmacenBarco` - Componente lateral o inferior del juego que contiene los
/// barcos iniciales disponibles para ser arrastrados y colocados en el tablero.
/// Act√∫a como inventario visual de barcos antes del despliegue estrat√©gico.
/// ---------------------------------------------------------------------------
library;

import 'package:flame/components.dart';
import 'package:flutter/material.dart'; // Import para UniqueKey

import 'barco.dart'; // Clase `Barco`, que representa individualmente cada unidad flotante.
import 'tablero.txt'; // Importa la clase Tablero

/// ---------------------------------------------------------------------------
/// CLASE PRINCIPAL: AlmacenBarco
/// Representa un √°rea tipo "contenedor de barcos" en la UI del juego, permitiendo
/// a los jugadores ver y arrastrar los barcos hacia el tablero.
/// ---------------------------------------------------------------------------
class AlmacenBarco extends PositionComponent with HasGameRef {
  // ===========================================================================
  // üîó PAR√ÅMETROS DE CONFIGURACI√ìN
  // ===========================================================================

  /// Lista de datos de los barcos iniciales (usados como plantillas).
  final List<Map<String, dynamic>> datosBarcosIniciales;

  /// Espaciado horizontal entre cada barco en p√≠xeles.
  final double espacioEntreBarcos;

  /// Referencia al tablero del juego donde se colocar√°n los barcos.
  final Tablero tablero;

  /// Componente interno que contiene y organiza visualmente los barcos.
  late final PositionComponent contenedorScroll;

  // ===========================================================================
  // üèóÔ∏è CONSTRUCTOR
  // ===========================================================================

  /// Crea un nuevo `AlmacenBarco` en una posici√≥n espec√≠fica y con tama√±o dado.
  ///
  /// - [datosBarcosIniciales]: Lista de mapas con la configuraci√≥n de cada barco.
  /// - [espacioEntreBarcos]: separaci√≥n horizontal entre cada barco.
  /// - [tablero]: Referencia al componente Tablero.
  /// - [position]: posici√≥n del componente en la pantalla.
  /// - [size]: dimensiones del √°rea del almac√©n.
  AlmacenBarco({
    required this.datosBarcosIniciales,
    required this.espacioEntreBarcos,
    required this.tablero,
    required Vector2 position,
    required Vector2 size,
  }) : super(position: position, size: size);

  // ===========================================================================
  // üöÄ CICLO DE VIDA - CARGA DEL COMPONENTE
  // ===========================================================================

  /// Se llama autom√°ticamente cuando el componente es insertado en el juego.
  /// Se encarga de inicializar visualmente el almac√©n y colocar los barcos.
  @override
  Future<void> onLoad() async {
    // Crea un contenedor que funcionar√° como scroll horizontal (si se desea).
    contenedorScroll = PositionComponent();

    // Inserta el contenedor como hijo de este componente visual.
    add(contenedorScroll);

    // Posiciona visualmente los barcos dentro del contenedor.
    await _inicializarBarcos();
  }

  // ===========================================================================
  // üõ†Ô∏è M√âTODO PRIVADO: Inicializaci√≥n de Barcos Visuales
  // ===========================================================================

  /// Crea y posiciona los componentes visuales de los barcos iniciales.
  Future<void> _inicializarBarcos() async {
    double xOffset = 0; // Desplazamiento horizontal inicial

    // Itera sobre la configuraci√≥n de cada barco inicial
    for (final datosBarco in datosBarcosIniciales) {
      final barcoVisual = _crearBarcoVisual(datosBarco);
      barcoVisual.position = Vector2(
        xOffset,
        (size.y - barcoVisual.size.y) / 2, // Centrado vertical del barco
      );

      contenedorScroll.add(barcoVisual);
      xOffset += barcoVisual.size.x + espacioEntreBarcos;
    }

    // Ajusta el tama√±o del contenedor para que abarque todos los barcos
    contenedorScroll.size = Vector2(xOffset - espacioEntreBarcos, size.y);
  }

  // ===========================================================================
  // üè≠ M√âTODO PRIVADO: Creaci√≥n de la Instancia Visual del Barco
  // ===========================================================================

  /// Crea una instancia visual del `Barco` a partir de los datos de configuraci√≥n.
  Barco _crearBarcoVisual(Map<String, dynamic> datos) {
    final int longitud = datos['longitud'];
    final Map<String, String> rutasSprites = Map<String, String>.from(datos['sprites']);
    const double escala = 1.0; // Puedes hacerlo configurable si es necesario

    return Barco(
      longitud: longitud,
      rutasSprites: rutasSprites,
      escala: escala,
      // Los barcos en el almac√©n no interact√∫an con el tablero directamente al inicio
      onDragStartCallback: (barcoArrastrado) {
        // Crea una nueva instancia del barco que se va a arrastrar
        final nuevoBarco = _clonarBarco(barcoArrastrado);
        // A√±ade el nuevo barco a la escena en la posici√≥n del barco del almac√©n
        gameRef.add(nuevoBarco..position = barcoArrastrado.position.clone());
        // Establece el barco original del almac√©n como no visible durante el arrastre
        barcoArrastrado.removeFromParent();
      },
      onDragEndCallback: (barcoArrastrado) {
        // Cuando se suelta el barco, intentamos colocarlo en el tablero
        final gridPosition = tablero.worldToGrid(barcoArrastrado.position);
        final esValida = tablero.esPosicionValida(
          gridPosition,
          barcoArrastrado.longitud,
          barcoArrastrado.esVertical,
        );

        if (esValida) {
          tablero.agregarBarco(barcoArrastrado, gridPosition, barcoArrastrado.esVertical);
        } else {
          // Si la colocaci√≥n no es v√°lida, elimina el barco arrastrado
          barcoArrastrado.removeFromParent();
          // Re-crea el barco en el almac√©n
          final datosOriginal = datosBarcosIniciales.firstWhere(
            (data) =>
                data['longitud'] == barcoArrastrado.longitud &&
                data['sprites'].toString() == barcoArrastrado.barcoVisual.sprites.toString(),
          );
          final nuevoBarcoAlmacen = _crearBarcoVisual(datosOriginal);
          nuevoBarcoAlmacen.position = barcoArrastrado.position.clone();
          contenedorScroll.add(nuevoBarcoAlmacen);
          _reorganizarBarcosAlmacen(); // Opcional: reorganizar visualmente el almac√©n
        }
      },
    );
  }

  // ===========================================================================
  // üêë M√âTODO PRIVADO: Clonaci√≥n del Barco para Arrastrar
  // ===========================================================================

  /// Crea una nueva instancia del `Barco` a partir de otra instancia.
  Barco _clonarBarco(Barco barcoOriginal) {
    return Barco(
      longitud: barcoOriginal.longitud,
      rutasSprites: Map<String, String>.from(
        barcoOriginal.rutasSprites,
      ), // Usamos rutasSprites del Barco original
      escala: barcoOriginal.scale.x,
      onDragStartCallback: (barco) {}, // No necesitamos este callback en la copia
      onDragEndCallback: (barco) {}, // La l√≥gica de soltar se maneja en el Tablero
      id: UniqueKey().toString(), // Aseguramos que la copia tenga un nuevo ID
    );
  }

  // ===========================================================================
  // üîÑ M√âTODO PRIVADO: Reorganizaci√≥n Visual del Almac√©n (Opcional)
  // ===========================================================================

  /// Reorganiza la posici√≥n de los barcos en el almac√©n despu√©s de un arrastre cancelado.
  void _reorganizarBarcosAlmacen() {
    contenedorScroll.removeAll(contenedorScroll.children.whereType<Barco>());
    double xOffset = 0;
    for (final datosBarco in datosBarcosIniciales) {
      final barcoVisual = _crearBarcoVisual({...datosBarco}); // Crea una nueva instancia
      barcoVisual.position = Vector2(xOffset, (size.y - barcoVisual.size.y) / 2);
      contenedorScroll.add(barcoVisual);
      xOffset += barcoVisual.size.x + espacioEntreBarcos;
    }
    contenedorScroll.size = Vector2(xOffset - espacioEntreBarcos, size.y);
  }
}
